<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Duet Mock / Duet RRF — G-code HoloViewer (Cura-style motion)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0b0f14; --panel:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12); --text:#e8edf2; --muted:#9fb0c3; --neon1:#00f5ff; --neon2:#7c4dff }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:
      radial-gradient(1200px 1200px at 10% 10%, rgba(124,77,255,.18), transparent 50%),
      radial-gradient(900px 900px at 85% 30%, rgba(0,245,255,.12), transparent 55%),
      var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    .wrap{display:grid;grid-template-columns:360px 1fr;grid-template-rows:72px 1fr;gap:16px;height:100%;padding:16px}
    header{grid-column:1/3;display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border:1px solid var(--stroke);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));border-radius:16px;backdrop-filter:blur(8px)}
    .brand{display:flex;align-items:center;gap:14px}
    .logo{width:40px;height:40px;border-radius:10px;background:conic-gradient(from 130deg,var(--neon1),var(--neon2));box-shadow:0 0 24px rgba(124,77,255,.45)}
    .title{font-family:Orbitron,Inter;letter-spacing:.5px;font-weight:700}
    .right{display:flex;align-items:center;gap:12px}
    .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;color:#071018;background:linear-gradient(135deg,var(--neon1),var(--neon2));font-weight:700;cursor:pointer;box-shadow:0 6px 20px rgba(0,245,255,.18)}
    .btn.ghost{background:transparent;color:var(--text);border:1px solid var(--stroke);box-shadow:none}
    .panel{border:1px solid var(--stroke);background:var(--panel);border-radius:16px;backdrop-filter:blur(8px)}
    .side{display:flex;flex-direction:column;gap:16px}
    .section{padding:14px 14px 12px}
    .section h3{margin:0 0 10px 0;font-size:13px;letter-spacing:1.2px;text-transform:uppercase;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .k{font-size:12px;color:var(--muted)}
    .v{font-weight:700}
    #gcodeCanvas{width:100%;height:100%;display:block}
    .viewer{position:relative}
    .overlay{position:absolute;left:10px;top:10px;font-size:12px;color:var(--muted)}
    .log{padding:12px;font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;overflow:auto;max-height:220px}
    .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--stroke);color:var(--muted);font-size:12px}
    input[type=file]{display:none} label[for=file]{cursor:pointer}
    .progress{height:10px;border-radius:8px;border:1px solid var(--stroke);background:rgba(255,255,255,.06);overflow:hidden}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--neon1),var(--neon2));box-shadow:0 0 12px rgba(0,245,255,.45) inset}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .ctl{display:flex;flex-direction:column;gap:6px}
    .ctl label{font-size:12px;color:var(--muted)}
    .switch{display:flex;align-items:center;gap:8px;font-size:12px;color:var(--muted)}
    @media (max-width:980px){.wrap{grid-template-columns:1fr;grid-template-rows:72px 240px 1fr}.viewer{grid-row:2}.side{grid-row:3}}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="panel">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="title">Duet Mock / Duet RRF — G-code HoloViewer</div>
          <div style="font-size:12px;color:var(--muted)">Smooth Path2D render • Live/Preview motion • Upload & start</div>
        </div>
      </div>
      <div><img src="/logo.svg" alt="Logo" style="width: 100px;" /></div>
      <div class="right">
        <span class="pill" id="apiBasePill">API: …</span>
        <span class="pill" id="apiModePill">mode: auto</span>
        <input id="file" type="file" accept=".gcode,.gco,.gc" />
        <label class="btn ghost" for="file">Upload .gcode</label>
        <button class="btn" id="reloadBtn">Reload</button>
      </div>
    </header>

    <div class="panel side">
      <div class="section">
        <h3>Machine</h3>
        <div class="grid">
          <div><div class="k">State</div><div class="v" id="state">-</div></div>
          <div><div class="k">Uptime</div><div class="v" id="uptime">-</div></div>
          <div><div class="k">Job</div><div class="v" id="job">-</div></div>
          <div><div class="k">Progress</div><div class="v" id="prog">0%</div></div>
        </div>
      </div>

      <div class="section">
        <h3>View Controls</h3>
        <div class="controls">
          <div class="ctl">
            <label>Mode</label>
            <div class="switch"><input id="singleLayer" type="checkbox"  /> Single-layer focus</div>
            <div class="switch"><input id="heatmap" type="checkbox" checked /> Color by height</div>
            <div class="switch"><input id="showTravel" type="checkbox" checked /> Show travel</div>
            <div class="switch"><input id="showHeads" type="checkbox" checked /> Show head(s)</div>
            <div class="switch"><input id="onlyPrinted" type="checkbox" checked /> Only show printed layers</div>
            <div class="switch"><input id="followPrint" type="checkbox" checked /> Follow current layer</div>
            <div class="switch"><input id="autoScan" type="checkbox" disabled /> Auto-scan layers</div>
          </div>
          <div class="ctl">
            <label>Layer (Z)</label>
            <input type="range" id="zSlider" min="0" max="1" step="0.001" value="0" />
            <div class="k">Z: <span class="v" id="zNow">—</span> / <span id="zSpan">—</span> (window <span id="zWin">0.25</span>mm)</div>
            <input type="range" id="zWindow" min="0.05" max="1.00" step="0.05" value="0.25" />
            <div class="k">Scan speed: <span class="v" id="scanV">0.25</span>×</div>
            <input type="range" id="scanSpeed" min="0.05" max="2.0" step="0.05" value="0.25" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Progress</h3>
        <div class="progress"><div class="bar" id="bar"></div></div>
      </div>

      <div class="section">
        <h3>Logs</h3>
        <div class="panel log" id="log" style="height:200px"></div>
      </div>

      <div class="section" style="padding-bottom:18px">
        <h3>Quick Tips</h3>
        <div style="font-size:12px;color:var(--muted)">
          • Auto-detects Mock vs Duet RRF. Change <b>API_BASE</b> below.<br>
          • Cura-style motion: local timeline + Duet sync.<br>
          • Serve via <code>python -m http.server 5500</code>.
        </div>
      </div>
    </div>

    <div class="panel viewer">
      <canvas id="gcodeCanvas"></canvas>
      <div class="overlay" id="overlay">—</div>
    </div>
  </div>

  <script>
    /* ===== CONFIG ===== */
    const API_BASE = 'http://localhost:3001';
    let API_MODE = 'duet'; // 'auto' | 'mock' | 'duet'

    /* ===== Normalized API adapters ===== */
    const PATHS = {
      mock: {
        status: () => fetch(API_BASE + '/machine/status', { cache: 'no-store' }).then(r => r.json()),
        download: (name) => fetch(API_BASE + '/machine/file/download?name=' + encodeURIComponent(name.replace(/^\/+/, '')), { cache: 'no-store' }).then(r => r.text()),
        upload: (file, dest) => { const fd = new FormData(); fd.append('file', file); return fetch(API_BASE + '/machine/file/upload', { method: 'POST', body: fd }); },
        start: (path) => fetch(API_BASE + '/machine/job/start?file=' + encodeURIComponent(path), { method: 'POST' }),
        normalize: (j) => ({
          state: { status: j?.state?.status || j?.state || 'unknown' },
          system: { uptime: j?.system?.uptime ?? 0 },
          job: { file: j?.job?.file || null, progress: j?.job?.progress || { completion: 0 } },
          // coords.xyz may exist; we ignore and drive from timeline for smoothness
          heads: []
        })
      },
      duet: {
        status: () => fetch(API_BASE + '/rr_status?type=3', { cache: 'no-store' }).then(r => r.json()),
        download: (name) => fetch(API_BASE + '/rr_download?name=' + encodeURIComponent(name.startsWith('/gcodes/') ? name : '/gcodes/' + name), { cache: 'no-store' }).then(r => r.text()),
        upload: (file, dest) => fetch(API_BASE + '/rr_upload?name=' + encodeURIComponent('/gcodes/' + dest), { method: 'POST', body: file, headers: { 'Content-Type': 'application/octet-stream' } }),
        start: (path) => fetch(API_BASE + '/rr_gcode?gcode=' + encodeURIComponent('M32 "' + path + '"')),
        normalize: (j) => {
          const map = { P: 'printing', I: 'idle', S: 'stopped', M: 'paused', R: 'busy' };
          const st = (typeof j?.status === 'string') ? (map[j.status] || j.status) : 'unknown';
          let fn = null;
          if (j?.job?.file?.fileName) fn = j.job.file.fileName;
          else if (j?.job?.file?.name) fn = j.job.file.name;
          else if (j?.fileName) fn = j.fileName;

          let comp = 0;
          if (j?.job?.progress?.completion != null) comp = j.job.progress.completion;
          else if (j?.fractionPrinted != null) comp = j.fractionPrinted;
          else if (j?.job?.filePosition != null && j?.job?.fileSize) comp = j.job.filePosition / j.job.fileSize;

          return { state: { status: st }, system: { uptime: j?.time ?? 0 }, job: { file: fn ? { fileName: fn } : null, progress: { completion: comp || 0 } }, heads: [] };
        }
      }
    };

    /* ===== Runtime state ===== */
    let parsed = null, canvas, ctx, dims = { w: 0, h: 0 };
    let ui = {}; let lastJobPath = null; let api = PATHS.mock;
    let cached = null; // geometry cache (bins, travels, endpoints)
    let scanRAF = null;
    let followZ = null;
    let serverCompletion = 0;
    let loopStart = null, loopCompletion = 0, printedCompletion = 0, printedAll = false;

    function normalizeJobFilePath(p){
      if(!p) return null;
      let n = p.trim().replace(/^\/+/, '');
      n = n.replace(/^gcodes\/+/, '');
      return '/gcodes/' + n;
    }

    /* ===== Helpers ===== */
    const el = id => document.getElementById(id);
    function log(m) { const L = el('log'); const line = `[${new Date().toLocaleTimeString()}] ${m}`; L.textContent = line + "\n" + L.textContent; console.log(m); }
    function setText(id, v) { el(id).textContent = v; }
    function setBar(p) { el('bar').style.width = (Math.max(0, Math.min(1, p)) * 100).toFixed(1) + '%'; }
    function hslToHex(h, s, l) { s/=100; l/=100; const k=n=>(n+h/30)%12,a=s*Math.min(l,1-l),f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1))); return '#'+[f(0),f(8),f(4)].map(x=>Math.round(255*x).toString(16).padStart(2,'0')).join(''); }
    function clamp01(x){return Math.max(0,Math.min(1,x));}
    function lowerBound(arr, x, get=(v)=>v){ let lo=0, hi=arr.length; while(lo<hi){ const mid=(lo+hi>>>1); if(get(arr[mid])<x) lo=mid+1; else hi=mid; } return lo; }

    async function detectApiMode() {
      if (API_MODE !== 'auto') return API_MODE;
      try { const r = await fetch(API_BASE + '/machine/status', { cache: 'no-store' }); if (r.ok) { API_MODE = 'mock'; api = PATHS.mock; return API_MODE; } } catch {}
      try { const r = await fetch(API_BASE + '/rr_status?type=3', { cache: 'no-store' }); if (r.ok) { API_MODE = 'duet'; api = PATHS.duet; return API_MODE; } } catch {}
      API_MODE = 'mock'; api = PATHS.mock; return API_MODE;
    }

    /* ===== Parser for multi-head (G0/G1 on X/U/V/Y/Z) ===== */
    function parseGcodeText(txt){
      let posAbs=true;
      const heads=[{x:0,y:0,z:0},{x:0,y:0,z:0},{x:0,y:0,z:0}];
      const commands=[]; const segments=[]; let t=0;
      const lines=txt.split(/\r?\n/);
      for(const raw of lines){
        const line0=raw.split(';')[0].trim(); if(!line0) continue;
        const line=line0.replace(/^N\d+\s*/i,'');
        if(/\bG90\b/i.test(line)){ posAbs=true; continue; }
        if(/\bG91\b/i.test(line)){ posAbs=false; continue; }
        if(/\bG92\b/i.test(line)){
          const mX=/X(-?\d+(?:\.\d+)?)/i.exec(line); if(mX) heads[0].x=parseFloat(mX[1]);
          const mU=/U(-?\d+(?:\.\d+)?)/i.exec(line); if(mU) heads[1].x=parseFloat(mU[1]);
          const mV=/V(-?\d+(?:\.\d+)?)/i.exec(line); if(mV) heads[2].x=parseFloat(mV[1]);
          const mY=/Y(-?\d+(?:\.\d+)?)/i.exec(line); if(mY) heads.forEach(h=>h.y=parseFloat(mY[1]));
          const mZ=/Z(-?\d+(?:\.\d+)?)/i.exec(line); if(mZ) heads.forEach(h=>h.z=parseFloat(mZ[1]));
          continue;
        }
        const isMove=/\bG0?1\b/i.test(line);
        if(isMove){
          const isExtrude=/\bG1\b/i.test(line);
          const mX=/X(-?\d+(?:\.\d+)?)/i.exec(line);
          const mU=/U(-?\d+(?:\.\d+)?)/i.exec(line);
          const mV=/V(-?\d+(?:\.\d+)?)/i.exec(line);
          const mY=/Y(-?\d+(?:\.\d+)?)/i.exec(line);
          const mZ=/Z(-?\d+(?:\.\d+)?)/i.exec(line);
          let nx=[heads[0].x,heads[1].x,heads[2].x];
          let ny=heads[0].y, nz=heads[0].z;
          if(mX) nx[0]=posAbs?parseFloat(mX[1]):nx[0]+parseFloat(mX[1]);
          if(mU) nx[1]=posAbs?parseFloat(mU[1]):nx[1]+parseFloat(mU[1]);
          if(mV) nx[2]=posAbs?parseFloat(mV[1]):nx[2]+parseFloat(mV[1]);
          if(mY) ny=posAbs?parseFloat(mY[1]):ny+parseFloat(mY[1]);
          if(mZ) nz=posAbs?parseFloat(mZ[1]):nz+parseFloat(mZ[1]);

          const segs=[]; let maxLen=0;
          for(let i=0;i<3;i++){
            const s={head:i,x1:heads[i].x,y1:heads[i].y,z1:heads[i].z,x2:nx[i],y2:ny,z2:nz,extrude:isExtrude};
            if(s.x1!==s.x2||s.y1!==s.y2||s.z1!==s.z2){
              const L=Math.hypot(s.x2-s.x1,s.y2-s.y1,s.z2-s.z1); s.len=L; segs.push(s); if(L>maxLen) maxLen=L;
            }
          }
          if(segs.length){
            const dt=maxLen/10; const t0=t, t1=t+dt;
            for(const s of segs){ s.t0=t0; s.t1=t1; s.dt=dt; segments.push(s); }
            const start=heads.map(h=>({...h}));
            const end=[{x:nx[0],y:ny,z:nz},{x:nx[1],y:ny,z:nz},{x:nx[2],y:ny,z:nz}];
            commands.push({segments:segs,start,end,t0,t1});
            heads[0].x=nx[0]; heads[1].x=nx[1]; heads[2].x=nx[2];
            heads.forEach(h=>{h.y=ny;h.z=nz;});
            t=t1;
          }
        }
      }
      // BBox
      let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
      for(const s of segments){
        minX=Math.min(minX,s.x1,s.x2); minY=Math.min(minY,s.y1,s.y2); minZ=Math.min(minZ,s.z1,s.z2);
        maxX=Math.max(maxX,s.x1,s.x2); maxY=Math.max(maxY,s.y1,s.y2); maxZ=Math.max(maxZ,s.z1,s.z2);
      }
      if(!isFinite(minX)){ minX=0;minY=0;minZ=0;maxX=10;maxY=10;maxZ=1; }
      const commandEndTimes=commands.map(c=>c.t1);
      return {segments,commands,commandEndTimes,totalTime:t,bbox:{minX,minY,minZ,maxX,maxY,maxZ},zMin:minZ,zMax:maxZ};
    }

    /* ===== Geometry cache (bins by MID-Z) ===== */
    function rebuildCache() {
      if (!parsed || !ctx) return;
      const { segments, bbox, zMin, zMax } = parsed;
      const w = dims.w, h = dims.h, m = 24;
      const bx = bbox.maxX - bbox.minX, by = bbox.maxY - bbox.minY;
      const s = Math.min((w - 2*m)/(bx||1), (h - 2*m)/(by||1));
      const ox = m + (w - 2*m - bx*s)/2, oy = m + (h - 2*m - by*s)/2;
      const toXY = (X,Y) => ({ x: ox + (X - bbox.minX)*s, y: h - (oy + (Y - bbox.minY)*s) });

      const BIN = 64, bins = Array.from({length:BIN}, ()=>new Path2D());
      const binLow = new Array(BIN), binHigh = new Array(BIN), binCount = new Array(BIN).fill(0);
      const travels = new Path2D();
      const endpoints = []; // extruding endpoints in world coords

      for (let i=0;i<BIN;i++){ const low=zMin+i*(zMax-zMin)/BIN, high=zMin+(i+1)*(zMax-zMin)/BIN; binLow[i]=low; binHigh[i]=high; }

      for (const seg of segments){
        const a=toXY(seg.x1,seg.y1), b=toXY(seg.x2,seg.y2);
        const zMid=(seg.z1+seg.z2)/2; const t=(zMid - zMin)/(zMax - zMin || 1);
        const bi=Math.min(BIN-1,Math.max(0,Math.floor(t*BIN)));
        if (seg.extrude){ bins[bi].moveTo(a.x,a.y); bins[bi].lineTo(b.x,b.y); endpoints.push({x:seg.x2,y:seg.y2,z:seg.z2,bin:bi}); binCount[bi]++; }
        else { travels.moveTo(a.x,a.y); travels.lineTo(b.x,b.y); }
      }

      cached = { bins, travels, endpoints, zMin, zMax, bbox, ox, oy, scale:s, margin:m, toXY, binLow, binHigh, binCount };
    }

    /* ===== Sampling along the timeline ===== */
    function headsAtTime(t){
      if(!parsed || !parsed.commands.length) return null;
      const times=parsed.commandEndTimes;
      let i=lowerBound(times,t);
      if(i>=parsed.commands.length) i=parsed.commands.length-1;
      const cmd=parsed.commands[i];
      const prevEnd=(i>0)?parsed.commands[i-1].end:cmd.start;
      const heads=[];
      for(let h=0;h<3;h++){
        const seg=cmd.segments.find(s=>s.head===h);
        if(t<cmd.t0){ heads[h]=prevEnd[h]; }
        else if(t>=cmd.t1){ heads[h]=cmd.end[h]; }
        else if(seg){ const u=(t-cmd.t0)/(cmd.t1-cmd.t0); heads[h]={x:seg.x1+(seg.x2-seg.x1)*u,y:seg.y1+(seg.y2-seg.y1)*u,z:seg.z1+(seg.z2-seg.z1)*u}; }
        else heads[h]=cmd.start[h];
      }
      return heads;
    }
    function headsAtCompletion(frac){
      if(!parsed) return null;
      const t=clamp01(frac)*(parsed.totalTime||0);
      return headsAtTime(t);
    }

    /* ===== Render ===== */
    function drawGrid() {
      const w = dims.w, h = dims.h;
      ctx.save(); ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let i=0;i<w;i+=40){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,h); ctx.stroke(); }
      for (let j=0;j<h;j+=40){ ctx.beginPath(); ctx.moveTo(0,j); ctx.lineTo(w,j); ctx.stroke(); }
      ctx.restore();
    }
    const HEAD_COLORS=['#00f5ff','#ff5cf0','#ffe04d','#9cff66'];
    function drawHeadsWorld(worldHeads){
      worldHeads.forEach((h,i)=>{ const p=cached.toXY(h.x,h.y); const c=HEAD_COLORS[i%HEAD_COLORS.length];
        ctx.shadowBlur=10; ctx.shadowColor=c+'99'; ctx.fillStyle=c; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
        ctx.shadowBlur=0; ctx.strokeStyle=c+'66'; ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.stroke();
      });
    }
    function nearestPrintedBinOrBelow(targetBin){
      for (let i=targetBin;i>=0;i--){ if (cached.binCount[i]>0) return i; }
      return -1;
    }

    function draw(){
      if(!ctx) return;
      const w=dims.w,h=dims.h; ctx.clearRect(0,0,w,h); drawGrid();
      if(!parsed || !cached) return;

      const single=ui.singleLayer.checked, heat=ui.heatmap.checked, showT=ui.showTravel.checked, showH=ui.showHeads.checked, onlyPrinted=ui.onlyPrinted.checked;

      const zMin=cached.zMin,zMax=cached.zMax;
      const zWin=parseFloat(ui.zWindow.value||'0.25'), zFrac=parseFloat(ui.zSlider.value||'0');
      let zC = zMin + (zMax - zMin) * zFrac;

      // Printed boundary from loop progress
      let zPrintedHi=zC;
      if(onlyPrinted){
        const hs=headsAtCompletion(printedCompletion||0);
        if(hs && hs[0]) zPrintedHi=hs[0].z;
      }

      const binH=(zMax-zMin)/cached.bins.length;
      let targetBin=Math.max(0,Math.min(cached.bins.length-1,Math.floor((zC - zMin)/(binH||1))));
      if(single && onlyPrinted){
        const printedBin=Math.max(0,Math.min(cached.bins.length-1,Math.floor(((zPrintedHi - zMin)/(binH||1)))));
        targetBin=Math.min(targetBin,printedBin);
        const snap=nearestPrintedBinOrBelow(targetBin);
        if(snap>=0){ const low=cached.binLow[snap], high=cached.binHigh[snap]; zC=(low+high)/2; }
      }

      setText('zNow', zC.toFixed(3)); setText('zSpan', `${zMin.toFixed(3)}–${zMax.toFixed(3)}`); setText('zWin', zWin.toFixed(2));
      if(showT && printedAll){ ctx.lineWidth=1.1; ctx.strokeStyle='rgba(19, 220, 255, 0.58)'; ctx.stroke(cached.travels); }

      const zLo=zC - zWin/2, zHi=zC + zWin/2;
      ctx.lineWidth=2.0;

      if(printedAll){
        const drawBin=(i,color)=>{ ctx.strokeStyle=color; ctx.stroke(cached.bins[i]); };
        if(heat){
          for(let i=0;i<cached.bins.length;i++){ const low=cached.binLow[i], high=cached.binHigh[i];
            if(single && (high<zLo||low>zHi)) continue;
            if(onlyPrinted && high>zPrintedHi+1e-6) continue;
            const t=((low+high)/2 - zMin)/(zMax - zMin || 1);
            drawBin(i, hslToHex(200 + 140*t, 100, 60));
          }
        } else {
          const grad=ctx.createLinearGradient(0,0,w,h); grad.addColorStop(0,'#00f5ff'); grad.addColorStop(1,'#7c4dff');
          for(let i=0;i<cached.bins.length;i++){ const low=cached.binLow[i], high=cached.binHigh[i];
            if(single && (high<zLo||low>zHi)) continue;
            if(onlyPrinted && high>zPrintedHi+1e-6) continue;
            drawBin(i, grad);
          }
        }
      } else {
        const limitT=printedCompletion*(parsed.totalTime||0);
        for(const s of parsed.segments){
          if(s.t0>limitT) break;
          if(!s.extrude && !showT) continue;
          const endT=Math.min(limitT,s.t1);
          const u=(s.dt>0)?((endT - s.t0)/s.dt):1;
          const zEnd=s.z1+(s.z2-s.z1)*u;
          const zMid=(s.z1+zEnd)/2;
          if(single && (zMid<zLo||zMid>zHi)) continue;
          if(onlyPrinted && zEnd>zPrintedHi+1e-6) continue;
          const a=cached.toXY(s.x1,s.y1);
          const b=cached.toXY(s.x1+(s.x2-s.x1)*u, s.y1+(s.y2-s.y1)*u);
          ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
          if(heat && s.extrude){ const tt=((zMid - zMin)/(zMax - zMin || 1)); ctx.strokeStyle=hslToHex(200 + 140*tt,100,60); }
          else if(s.extrude) ctx.strokeStyle='#00f5ff';
          else ctx.strokeStyle='rgba(19, 220, 255, 0.58)';
          ctx.stroke();
        }
      }

      if(showH){
        const hs=headsAtTime(loopCompletion*(parsed.totalTime||0));
        if(hs) drawHeadsWorld(hs);
      }

      el('overlay').textContent = `${parsed.segments.length} segments • ${(loopCompletion*100||0).toFixed(1)}% ${single?`• Z≈${zC.toFixed(2)}mm`:''}`;

      if(ui.followPrint.checked && cached){
        const hs=headsAtCompletion(printedCompletion||0);
        if(hs && hs[0]){
          const targetFrac=(hs[0].z - cached.zMin)/(cached.zMax - cached.zMin || 1);
          if(isFinite(targetFrac)){
            followZ=(followZ==null)?targetFrac:(followZ*0.85 + targetFrac*0.15);
            ui.zSlider.value=clamp01(followZ);
          }
        }
      }
    }

    /* ===== Data / polling ===== */
    async function getNormalizedStatus(){ const mode=await detectApiMode(); el('apiModePill').textContent='mode: '+mode; return api.status().then(api.normalize); }

    async function poll(){
      try{
        const st=await getNormalizedStatus();
        setText('state', st?.state?.status || '—');
        setText('uptime', (st?.system?.uptime ?? 0)+'s');
        serverCompletion = st?.job?.progress?.completion ?? 0;
        setBar(serverCompletion); setText('prog', ((serverCompletion*100)||0).toFixed(1)+'%');

        const filePath=st?.job?.file?.fileName || null; setText('job', filePath || '—');
        const norm=filePath?normalizeJobFilePath(filePath):null;
        if(norm && norm!==lastJobPath){
          log('Job file: '+norm+' — fetching…');
          const txt=await api.download(norm);
          parsed=parseGcodeText(txt); lastJobPath=norm; rebuildCache();
          loopStart=performance.now(); loopCompletion=0; printedCompletion=0; printedAll=false;
          log(`G-code loaded: ${parsed.segments.length} segments • heads=3 • loop ${(parsed.totalTime||0).toFixed(1)}s @ F600`);
        }
      } catch(e){ log('poll error: '+e.message); }
      finally { setTimeout(poll,1000); }
    }

    /* ===== Upload / start ===== */
    async function uploadAndStart(file){
      const dest = file.name || 'upload.gcode';
      try{
        await detectApiMode();
        const r = await api.upload(file, dest); if (!r.ok) throw new Error('upload failed '+r.status);
        const serverFile = '/gcodes/' + dest; log('Uploaded: ' + serverFile);
        const s = await api.start(serverFile); if (!s.ok) throw new Error('start failed '+s.status);
        log('Start command sent: ' + serverFile);
      } catch(err){ log('upload/start error: '+err.message+' (starting from Duet Web Control is also fine)'); }
    }

    function animate(){
      if(parsed){
        const total=parsed.totalTime||1;
        const now=performance.now();
        if(loopStart==null) loopStart=now;
        const elapsed=(now-loopStart)/1000;
        loopCompletion=(elapsed%total)/total;
        if(!printedAll){
          printedCompletion=Math.min(1,elapsed/total);
          if(printedCompletion>=1) printedAll=true;
        }
      }
      draw();
      requestAnimationFrame(animate);
    }

    /* ===== Auto-scan (layer sweep) ===== */
    // let scanRAF=null; // Removed duplicate declaration
    function startScan(){
      stopScan(); const speed=parseFloat(ui.scanSpeed.value||'0.25'); const step=speed/2000;
      function tick(){ if(!ui.autoScan.checked){ scanRAF=null; return; }
        let v=parseFloat(ui.zSlider.value); v+=step; if(v>1) v=0; ui.zSlider.value=v; draw(); scanRAF=requestAnimationFrame(tick); }
      scanRAF=requestAnimationFrame(tick);
    }
    function stopScan(){ if(scanRAF){ cancelAnimationFrame(scanRAF); scanRAF=null; } }

    /* ===== Bootstrap ===== */
    function resize(){
      const c=el('gcodeCanvas'), r=c.parentElement.getBoundingClientRect();
      const w=Math.floor(r.width), h=Math.floor(r.height); if (w===dims.w && h===dims.h) return;
      dims={w,h}; c.width=w*devicePixelRatio; c.height=h*devicePixelRatio; c.style.width=w+'px'; c.style.height=h+'px';
      ctx=c.getContext('2d'); ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); if(parsed) rebuildCache(); draw();
    }
    function init(){
      ui = {
        singleLayer: el('singleLayer'), heatmap: el('heatmap'), showTravel: el('showTravel'),
        showHeads: el('showHeads'), zSlider: el('zSlider'), zWindow: el('zWindow'),
        autoScan: el('autoScan'), scanSpeed: el('scanSpeed'), followPrint: el('followPrint'),
        onlyPrinted: el('onlyPrinted')
      };
      el('apiBasePill').textContent='API: '+API_BASE;
      el('scanV').textContent=ui.scanSpeed.value;
      ui.zSlider.disabled = ui.followPrint.checked;

      el('file').addEventListener('change', e=>{ const f=e.target.files[0]; if(f) uploadAndStart(f); });
      el('reloadBtn').addEventListener('click', ()=>{ lastJobPath=null; });
      window.addEventListener('resize', resize);

      ['change','input'].forEach(ev=>{
        ui.singleLayer.addEventListener(ev, ()=>draw());
        ui.heatmap.addEventListener(ev, ()=>draw());
        ui.showTravel.addEventListener(ev, ()=>draw());
        ui.showHeads.addEventListener(ev, ()=>draw());
        ui.onlyPrinted.addEventListener(ev, ()=>draw());
        ui.zSlider.addEventListener(ev, ()=>{ followZ=null; draw(); });
        ui.zWindow.addEventListener(ev, ()=>draw());
        ui.scanSpeed.addEventListener(ev, ()=>{ el('scanV').textContent=ui.scanSpeed.value; if(ui.autoScan.checked){ startScan(); } });
        ui.autoScan.addEventListener('change', ()=>{ if(ui.autoScan.checked){ ui.followPrint.checked=false; ui.onlyPrinted.checked=false; ui.zSlider.disabled=false; startScan(); } else { stopScan(); } draw(); });
        ui.followPrint.addEventListener(ev, ()=>{ ui.zSlider.disabled=ui.followPrint.checked; if(ui.followPrint.checked){ ui.autoScan.checked=false; stopScan(); } followZ=null; draw(); });
      });

      canvas = el('gcodeCanvas'); ctx = canvas.getContext('2d'); resize(); poll(); animate();
    }
    init();
  </script>
</body>
</html>
